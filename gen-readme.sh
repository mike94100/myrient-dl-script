#!/usr/bin/env bash
set -uo pipefail

# Generate README.md from platform TOML file
# Usage: gen-readme.sh <toml_file>

# Parse TOML using Python
parse_toml() {
python3 - "$1" <<'EOF'
import sys, json

try:
    import tomllib  # Python 3.11+
except ImportError:
    import tomli as tomllib  # fallback for older Python

with open(sys.argv[1], "rb") as f:
    data = tomllib.load(f)

print(json.dumps(data))
EOF
}

# URL decode using Python
url_decode() {
python3 -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.argv[1]))" "$1"
}

# Check if a TOML is a meta config (contains platform_tomls[] array)
is_meta_toml() {
    local file="$1"
    local json=$(parse_toml "$file")
    local platform_tomls=$(printf "%s" "$json" | jq -r '.platform_tomls // empty')
    [[ -n "$platform_tomls" ]]
}

log() {
    echo "$*" >&2
}

show_help() {
    cat << EOF
NAME
    gen-readme.sh - Generate README.md files from platform TOML configurations

SYNOPSIS
    gen-readme.sh [OPTIONS] <toml_file>

DESCRIPTION
    This script reads a platform TOML file (generated by gen-platform-toml.sh) and
    creates a human-readable README.md file with decoded filenames and metadata.

ARGUMENTS
    toml_file
        Path to the platform TOML file (e.g., gb.toml)

OPTIONS
    -h, --help
        Display this help message and exit.

OUTPUT
    Creates a README.md file in the same directory as the input TOML file.
    The README contains:
    - Platform title and description
    - Generation date and time (UTC)
    - Source URL
    - Total number of files
    - Total download size (calculated from source)
    - Complete list of human-readable filenames

EXAMPLES
    gen-readme.sh testconfigs/gb.toml
    gen-readme.sh --help

SEE ALSO
    gen-platform-toml.sh - Generate TOML files by scraping Myrient pages
    myrient-dl.sh - Download ROMs using TOML configurations

EOF
}

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            log "Unknown option: $1"
            log "Use -h or --help for usage"
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# Check arguments
if [[ $# -ne 1 ]]; then
    log "Usage: $0 [OPTIONS] <toml_file>"
    log "Use -h or --help for detailed help"
    exit 1
fi

TOML_FILE="$1"

if [[ ! -f "$TOML_FILE" ]]; then
    log "ERROR: File not found: $TOML_FILE"
    exit 1
fi

# Get base URL from config.toml first (needed for both meta and platform handling)
if [[ ! -f "./config.toml" ]]; then
    log "ERROR: config.toml not found in current directory"
    exit 1
fi

CONFIG_JSON=$(parse_toml "./config.toml")
BASE_URL=$(printf "%s" "$CONFIG_JSON" | jq -r '.base_url')

if [[ -z "$BASE_URL" ]]; then
    log "ERROR: base_url not found in config.toml"
    exit 1
fi

# Check if this is a meta TOML
if is_meta_toml "$TOML_FILE"; then
    # Handle meta TOML - first generate READMEs for all platforms, then create summary
    JSON=$(parse_toml "$TOML_FILE")
    mapfile -t PLATFORM_FILES < <(printf "%s" "$JSON" | jq -r '.platform_tomls[]')

    log "Processing meta TOML with ${#PLATFORM_FILES[@]} platforms"

    # First, generate READMEs for all individual platforms
    for platform_file in "${PLATFORM_FILES[@]}"; do
        platform_path="$(dirname "$TOML_FILE")/$platform_file"
        if [[ -f "$platform_path" ]]; then
            log "Generating README for platform: $platform_file"
            # Recursively call gen-readme.sh for this platform
            "$0" "$platform_path" >/dev/null 2>&1
        fi
    done

    # Now calculate summary info for all platforms
    TOTAL_FILES=0
    TOTAL_SIZE_BYTES=0
    PLATFORM_SUMMARY=""

    for platform_file in "${PLATFORM_FILES[@]}"; do
        platform_path="$(dirname "$TOML_FILE")/$platform_file"
        if [[ -f "$platform_path" ]]; then
            platform_json=$(parse_toml "$platform_path")
            platform_name=$(basename "$platform_file" .toml | tr '[:lower:]' '[:upper:]')
            platform_directory=$(printf "%s" "$platform_json" | jq -r '.directory // empty')
            mapfile -t platform_files < <(printf "%s" "$platform_json" | jq -r '.files[]')

            TOTAL_FILES=$((TOTAL_FILES + ${#platform_files[@]}))

            # Scrape sizes for this platform
            platform_subdomain=$(printf "%s" "$platform_json" | jq -r '.subdomain // empty')
            platform_source_url="${BASE_URL%/}/${platform_subdomain#/}"
            platform_html=$(curl -s "$platform_source_url")

            platform_size_bytes=0
            for file in "${platform_files[@]}"; do
                size_info=$(echo "$platform_html" | grep -A2 "$file" | grep '<td class="size">' | sed 's/.*<td class="size">//;s/<\/td>.*//' | head -1)
                if [[ -n "$size_info" && "$size_info" != "-" ]]; then
                    size_num=$(echo "$size_info" | sed 's/^\([0-9.]*\).*/\1/')
                    size_unit=$(echo "$size_info" | sed 's/^[0-9.]*\s*//' | sed 's/\s*$//')
                    case "$size_unit" in
                        B)    file_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num}") ;;
                        KiB)  file_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num * 1024}") ;;
                        MiB)  file_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num * 1024 * 1024}") ;;
                        GiB)  file_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num * 1024 * 1024 * 1024}") ;;
                        TiB)  file_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num * 1024 * 1024 * 1024 * 1024}") ;;
                        *)    file_bytes=0 ;;
                    esac
                    platform_size_bytes=$((platform_size_bytes + file_bytes))
                fi
            done

            TOTAL_SIZE_BYTES=$((TOTAL_SIZE_BYTES + platform_size_bytes))
            PLATFORM_SUMMARY="${PLATFORM_SUMMARY}- [${platform_name}](${platform_directory}) (${#platform_files[@]} files) â†’ ${platform_directory}\n"
        fi
    done
    
    # Format total size with intelligent formatting
    if [[ $TOTAL_SIZE_BYTES -eq 0 ]]; then
        TOTAL_SIZE_FORMATTED="Unknown"
    elif command -v bc >/dev/null 2>&1; then
        size_gb=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1000000000" | bc)
        size_gib=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1073741824" | bc)
        if [[ $(echo "$size_gb >= 1" | bc) -eq 1 ]]; then
            gb_fmt=$( [[ $(echo "$size_gb >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            gib_fmt=$( [[ $(echo "$size_gib >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            TOTAL_SIZE_FORMATTED="$(printf "$gb_fmt GB" "$size_gb") ($(printf "$gib_fmt GiB" "$size_gib"))"
        else
            size_mb=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1000000" | bc)
            size_mib=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1048576" | bc)
            mb_fmt=$( [[ $(echo "$size_mb >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            mib_fmt=$( [[ $(echo "$size_mib >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            TOTAL_SIZE_FORMATTED="$(printf "$mb_fmt MB" "$size_mb") ($(printf "$mib_fmt MiB" "$size_mib"))"
        fi
    else
        if [[ $TOTAL_SIZE_BYTES -gt $((1000 * 1000 * 1000)) ]]; then
            gb_size=$(awk "BEGIN {gb = $TOTAL_SIZE_BYTES / 1000000000; printf gb >= 100 ? \"%.0f\" : \"%.1f\", gb}")
            gib_size=$(awk "BEGIN {gib = $TOTAL_SIZE_BYTES / 1073741824; printf gib >= 100 ? \"%.0f\" : \"%.1f\", gib}")
            TOTAL_SIZE_FORMATTED="${gb_size} GB (${gib_size} GiB)"
        else
            mb_size=$(awk "BEGIN {mb = $TOTAL_SIZE_BYTES / 1000000; printf mb >= 100 ? \"%.0f\" : \"%.1f\", mb}")
            mib_size=$(awk "BEGIN {mib = $TOTAL_SIZE_BYTES / 1048576; printf mib >= 100 ? \"%.0f\" : \"%.1f\", mib}")
            TOTAL_SIZE_FORMATTED="${mb_size} MB (${mib_size} MiB)"
        fi
    fi
    
    # Generate meta README
    README_FILE="$(dirname "$TOML_FILE")/README.md"
    
    {
        echo "# Multi-Platform ROM Collection"
        echo ""
        echo "This collection contains ROMs for multiple gaming platforms."
        echo ""
        echo "## Metadata"
        echo ""
        echo "- **Generated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "- **Total Platforms**: ${#PLATFORM_FILES[@]}"
        echo "- **Total Files**: $TOTAL_FILES"
        echo "- **Total Size**: $TOTAL_SIZE_FORMATTED"
        echo ""
        echo "## Included Platforms"
        echo ""
        echo "This collection includes the following platforms:"
        echo ""
        printf "%b" "$PLATFORM_SUMMARY"
        echo ""
        echo "## Download"
        echo ""
        echo "To download all platforms in this collection:"
        echo ""
        echo "\`\`\`bash"
        echo "./myrient-dl.sh \"$TOML_FILE\""
        echo "\`\`\`"
        echo ""
        echo "Or download to a custom directory:"
        echo ""
        echo "\`\`\`bash"
        echo "./myrient-dl.sh -o /path/to/directory \"$TOML_FILE\""
        echo "\`\`\`"
    } > "$README_FILE"
    
    log "Generated summary README.md for meta collection (${#PLATFORM_FILES[@]} platforms, $TOTAL_FILES files)"
    exit 0
fi

# Handle platform TOML
JSON=$(parse_toml "$TOML_FILE")

# Extract data
SUBDOMAIN=$(printf "%s" "$JSON" | jq -r '.subdomain // empty')
DIRECTORY=$(printf "%s" "$JSON" | jq -r '.directory // empty')
mapfile -t FILES < <(printf "%s" "$JSON" | jq -r '.files[]')

if [[ -z "$SUBDOMAIN" ]]; then
    log "ERROR: subdomain not found in $TOML_FILE"
    exit 1
fi

# Check if we're already in the correct platform directory
CURRENT_DIR_NAME=$(basename "$(dirname "$TOML_FILE")")
PLATFORM_DIR_NAME=$(basename "$TOML_FILE" .toml)

if [[ "$CURRENT_DIR_NAME" == "$PLATFORM_DIR_NAME" ]]; then
    # Already in correct directory structure
    PLATFORM_DIR="$(dirname "$TOML_FILE")"
    log "Already in correct platform directory: $PLATFORM_DIR"
else
    # Create platform directory and move files
    PLATFORM_DIR="$(dirname "$TOML_FILE")/$PLATFORM_DIR_NAME"
    log "Creating platform directory: $PLATFORM_DIR"
    mkdir -p "$PLATFORM_DIR"

    # Move TOML file to platform directory
    mv "$TOML_FILE" "$PLATFORM_DIR/"

    # Update TOML_FILE path for README generation
    TOML_FILE="$PLATFORM_DIR/$(basename "$TOML_FILE")"
fi

# Construct source URL
SOURCE_URL="${BASE_URL%/}/${SUBDOMAIN#/}"

# Generate platform name from directory
PLATFORM_NAME=$(basename "$DIRECTORY" / | tr '[:lower:]' '[:upper:]')

# Scrape file sizes from the source page
log "Scraping file sizes from: $SOURCE_URL"
HTML=$(curl -s "$SOURCE_URL")

# Calculate total size
TOTAL_SIZE_BYTES=0
SIZE_SUMMARY=""

for file in "${FILES[@]}"; do
    # Extract file size from Myrient's table format
    # Find the row containing the file link and extract the size from the next cell
    # Format: <tr><td class="link"><a href="filename.zip">...</a></td><td class="size">SIZE</td>...
    size_info=$(echo "$HTML" | grep -A2 "$file" | grep '<td class="size">' | sed 's/.*<td class="size">//;s/<\/td>.*//' | head -1)
    
    if [[ -n "$size_info" && "$size_info" != "-" ]]; then
        # Parse size (e.g., "35.9 KiB" -> bytes)
        # Extract number and unit separately
        size_num=$(echo "$size_info" | sed 's/^\([0-9.]*\).*/\1/')
        size_unit=$(echo "$size_info" | sed 's/^[0-9.]*\s*//' | sed 's/\s*$//')

        if [[ -n "$size_num" && -n "$size_unit" ]]; then
            # Convert to bytes using awk for floating point arithmetic
            case "$size_unit" in
                B)    size_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num}") ;;
                KiB)  size_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num * 1024}") ;;
                MiB)  size_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num * 1024 * 1024}") ;;
                GiB)  size_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num * 1024 * 1024 * 1024}") ;;
                TiB)  size_bytes=$(awk "BEGIN {printf \"%.0f\", $size_num * 1024 * 1024 * 1024 * 1024}") ;;
                *)    size_bytes=0 ;;
            esac

            TOTAL_SIZE_BYTES=$((TOTAL_SIZE_BYTES + size_bytes))

            if [[ -z "$SIZE_SUMMARY" ]]; then
                SIZE_SUMMARY="$size_info"
            fi
        fi
    fi
done

# Format total size with both decimal and binary units
if [[ $TOTAL_SIZE_BYTES -eq 0 ]]; then
    TOTAL_SIZE_FORMATTED="Unknown (unable to determine from source)"
else
    # Calculate both decimal (KB, MB, GB) and binary (KiB, MiB, GiB) representations
    if command -v bc >/dev/null 2>&1; then
        # Use bc for precise calculations
        size_kb=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1000" | bc)
        size_kib=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1024" | bc)
        size_mb=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1000000" | bc)
        size_mib=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1048576" | bc)
        size_gb=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1000000000" | bc)
        size_gib=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1073741824" | bc)
        size_tb=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1000000000000" | bc)
        size_tib=$(echo "scale=1; $TOTAL_SIZE_BYTES / 1099511627776" | bc)

        if [[ $(echo "$size_tb >= 1" | bc) -eq 1 ]]; then
            tb_fmt=$( [[ $(echo "$size_tb >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            tib_fmt=$( [[ $(echo "$size_tib >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            TOTAL_SIZE_FORMATTED="$(printf "$tb_fmt TB" "$size_tb") ($(printf "$tib_fmt TiB" "$size_tib"))"
        elif [[ $(echo "$size_gb >= 1" | bc) -eq 1 ]]; then
            gb_fmt=$( [[ $(echo "$size_gb >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            gib_fmt=$( [[ $(echo "$size_gib >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            TOTAL_SIZE_FORMATTED="$(printf "$gb_fmt GB" "$size_gb") ($(printf "$gib_fmt GiB" "$size_gib"))"
        elif [[ $(echo "$size_mb >= 1" | bc) -eq 1 ]]; then
            mb_fmt=$( [[ $(echo "$size_mb >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            mib_fmt=$( [[ $(echo "$size_mib >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            TOTAL_SIZE_FORMATTED="$(printf "$mb_fmt MB" "$size_mb") ($(printf "$mib_fmt MiB" "$size_mib"))"
        elif [[ $(echo "$size_kb >= 1" | bc) -eq 1 ]]; then
            kb_fmt=$( [[ $(echo "$size_kb >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            kib_fmt=$( [[ $(echo "$size_kib >= 100" | bc) -eq 1 ]] && echo "%.0f" || echo "%.1f" )
            TOTAL_SIZE_FORMATTED="$(printf "$kb_fmt KB" "$size_kb") ($(printf "$kib_fmt KiB" "$size_kib"))"
        else
            TOTAL_SIZE_FORMATTED="$TOTAL_SIZE_BYTES B"
        fi
    else
        # Fallback without bc - use awk for decimal calculations with intelligent formatting
        if [[ $TOTAL_SIZE_BYTES -gt $((1000 * 1000 * 1000 * 1000)) ]]; then
            kb_size=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE_BYTES / 1000}")
            kib_size=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE_BYTES / 1024}")
            TOTAL_SIZE_FORMATTED="${kb_size} KB (${kib_size} KiB)"
        elif [[ $TOTAL_SIZE_BYTES -gt $((1000 * 1000 * 1000)) ]]; then
            gb_size=$(awk "BEGIN {gb = $TOTAL_SIZE_BYTES / 1000000000; printf gb >= 100 ? \"%.0f\" : \"%.1f\", gb}")
            gib_size=$(awk "BEGIN {gib = $TOTAL_SIZE_BYTES / 1073741824; printf gib >= 100 ? \"%.0f\" : \"%.1f\", gib}")
            TOTAL_SIZE_FORMATTED="${gb_size} GB (${gib_size} GiB)"
        elif [[ $TOTAL_SIZE_BYTES -gt $((1000 * 1000)) ]]; then
            mb_size=$(awk "BEGIN {mb = $TOTAL_SIZE_BYTES / 1000000; printf mb >= 100 ? \"%.0f\" : \"%.1f\", mb}")
            mib_size=$(awk "BEGIN {mib = $TOTAL_SIZE_BYTES / 1048576; printf mib >= 100 ? \"%.0f\" : \"%.1f\", mib}")
            TOTAL_SIZE_FORMATTED="${mb_size} MB (${mib_size} MiB)"
        elif [[ $TOTAL_SIZE_BYTES -gt 1000 ]]; then
            kb_size=$(awk "BEGIN {kb = $TOTAL_SIZE_BYTES / 1000; printf kb >= 100 ? \"%.0f\" : \"%.1f\", kb}")
            kib_size=$(awk "BEGIN {kib = $TOTAL_SIZE_BYTES / 1024; printf kib >= 100 ? \"%.0f\" : \"%.1f\", kib}")
            TOTAL_SIZE_FORMATTED="${kb_size} KB (${kib_size} KiB)"
        else
            TOTAL_SIZE_FORMATTED="$TOTAL_SIZE_BYTES B"
        fi
    fi
fi

# Generate README
README_FILE="$(dirname "$TOML_FILE")/README.md"

{
    echo "# $PLATFORM_NAME ROM Collection"
    echo ""
    echo "This collection contains ROMs for the $PLATFORM_NAME platform."
    echo ""
    echo "## Metadata"
    echo ""
    echo "- **Generated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
    echo "- **Source URL**: $SOURCE_URL"
    echo "- **Total Files**: ${#FILES[@]}"
    echo "- **Total Size**: $TOTAL_SIZE_FORMATTED"
    echo "- **Platform Directory**: $DIRECTORY"
    echo ""
    echo "## ROM Files"
    echo ""
    echo "The following ${#FILES[@]} ROM files are included in this collection:"
    echo ""
    for file in "${FILES[@]}"; do
        human_name=$(url_decode "$file")
        echo "- $human_name"
    done
    echo ""
    echo "## Download"
    echo ""
    echo "To download all ROMs in this collection:"
    echo ""
    echo "\`\`\`bash"
    echo "./myrient-dl.sh \"$TOML_FILE\""
    echo "\`\`\`"
    echo ""
    echo "Or download to a custom directory:"
    echo ""
    echo "\`\`\`bash"
    echo "./myrient-dl.sh -o /path/to/directory \"$TOML_FILE\""
    echo "\`\`\`"
} > "$README_FILE"

log "Generated README.md for $PLATFORM_NAME (${#FILES[@]} files)"
